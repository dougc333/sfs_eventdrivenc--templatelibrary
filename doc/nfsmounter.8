.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "NFSMOUNTER 8"
.TH NFSMOUNTER 8 "2006-07-20" "SFS 0.8pre" "SFS 0.8pre"
.SH "NAME"
nfsmounter \- NFS mount/unmount daemon
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
/usr/local/lib/sfs\-0.8pre/nfsmounter [\-F] [\-P] /\fIprefix\fR
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBnfsmounter\fR is a program that calls the \fBmount\fR and
\&\fBunmount\fR (or \fBumount\fR, depending on the operating
system) system calls to create \s-1NFS\s0 mount points for \s-1NFS\s0 loopback
servers.  An \s-1NFS\s0 loopback server is a user-level program that speaks
the \s-1NFS\s0 file system protocol, effectively pretending to be a remote
file server even though it is just a process on the local machine.
\&\s-1SFS\s0 is implemented as an \s-1NFS\s0 loopback server to gain portability,
since most operating systems have built-in \s-1NFS\s0 clients.  Other file
systems built using the \s-1SFS\s0 file system toolkit also use
\&\fBnfsmounter\fR.
.PP
The only thing you really need to know about nfsmounter is that you
should \fInever send \fR\fBnfsmounter\fR\fI a \fR\fB\s-1SIGKILL\s0\fR\fI signal,
e.g., using the \fR\fBkill \-9\fR\fI command\fR.  If an \s-1NFS\s0 loopback server
seems to be misbehaving, you can find the corresponding
\&\fBnfsmounter\fR process through \fBps\fR (the \fIprefix\fR
argument will tell you which directory a particular
\&\fBnfsmounter\fR process is handling, if there are multiple
loopback servers on your machine) and send it a \fB\s-1SIGTERM\s0\fR signal
(\fBkill \-15\fR).  Upon receiving a \fB\s-1SIGTERM\s0\fR,
\&\fBnfsmounter\fR will drop its connection to the \s-1NFS\s0 loopback
server, take over the \s-1UDP\s0 sockets corresponding to the mount point,
and do its best to unmount all the file systems.
.PP
The rest of this \fBnfsmounter\fR description is mostly of
interest to people who are developing \s-1NFS\s0 loopback servers themselves.
.PP
\&\fBnfsmounter\fR must be run as root.  It expects its standard
input (file descriptor 0) to be a Unix-domain socket.  The program
that spawned \fBnfsmounter\fR communicates over that socket using
an \s-1RPC\s0 protocol defined in \fI/usr/local/include/sfs/nfsmounter.x\fR.
As part of the mount process, the program that invoked
\&\fBnfsmounter\fR must send it a copy of the server socket for the
\&\s-1NFS\s0 loopback server.  When \fBnfsmounter\fR detects an end of file
on standard input, it takes over these sockets so as to avoid having
processes hang (which would happen if the \s-1NFS\s0 loopback server simply
died) and attempts to unmount all file systems.  Thus, it is safe for
\&\s-1NFS\s0 loopback servers simply to exit.
.PP
If the \fB\s-1SFS_RUNINPLACE\s0\fR environment variable is set to a directory
and \fBnfsmounter\fR detects that its standard input is not a
Unix-domain socket, \fBnfsmounter\fR will instead bind Unix-domain
socket \fI$SFS_RUNINPLACE/runinplace/.nfsmounter\fR and wait for a
single connection.  The \fBsfscd\fR program knows to check for
this socket when \fB\s-1SFS_RUNINPLACE\s0\fR is set.  This option makes it
easy to run \fBsfscd\fR as a non-root user by starting
\&\fBnfsmounter\fR first, which in turn facilitates debugging with
emacs (without having to run everything as root).
.SH "OPTIONS"
.IX Header "OPTIONS"
.IP "\-F" 4
.IX Item "-F"
Disables forcible unmounting of file systems.  Forcible unmounting is
the system call flag that corresponds to the \fB\-f\fR flag of the
\&\fBumount\fR command.  If you are developing an \s-1NFS\s0 loopback
server that seems to panic the kernel a lot on exit, running
\&\fBnfsmounter\fR with \fB\-F\fR might help.
.IP "\-P" 4
.IX Item "-P"
Always pass absolute pathnames to the \fBmount\fR system call.
Ordinarily, as a defensive measure, \fBnfsmounter\fR changes
directory to the point where the mount is happening.  This is to avoid
accidentally following a symbolic link and creating a mountpoint on a
directory not under \fIprefix\fR.  However, calling \fBmount\fR with
a relative pathname cause the \fI/proc\fR file system or system
calls like \fBgetfsstat\fR to return relative pathnames, which can
confuse some applications.
.Sp
To fix the problem, after creating a mount point, \fBnfsmounter\fR
attempts to re-mount or update the mountpoint using the absolute
pathname.  Unfortunately, this trick does not work on some BSD-derived
operating systems, including MacOS.  Moreover, on the Macintosh in
particular, the finder gets very confused by relative mountpoint
names.  Thus, \s-1SFS\s0 uses the \fB\-P\fR option to nfsmounter on the
Macintosh.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIdirsearch\fR\|(1), \fInewaid\fR\|(1), \fIrex\fR\|(1), \fIsfsagent\fR\|(1), \fIsfskey\fR\|(1), \fIssu\fR\|(1), \fIsfs_config\fR\|(5), \fIsfs_hosts\fR\|(5), \fIsfs_srp_params\fR\|(5), \fIsfs_users\fR\|(5), \fIsfsauthd_config\fR\|(5), \fIsfscd_config\fR\|(5), \fIsfsrosd_config\fR\|(5), \fIsfsrwsd_config\fR\|(5), \fIsfssd_config\fR\|(5), \fIsfs_environ\fR\|(7), \fIfunmount\fR\|(8), \fIsfsauthd\fR\|(8), \fIsfscd\fR\|(8), \fIsfsrosd\fR\|(8), \fIsfsrwcd\fR\|(8), \fIsfsrwsd\fR\|(8), \fIsfssd\fR\|(8), \fIvidb\fR\|(8)
.PP
The full documentation for \fB\s-1SFS\s0\fR is maintained as a Texinfo
manual.  If the \fBinfo\fR and \fB\s-1SFS\s0\fR programs are properly installed
at your site, the command \fBinfo \s-1SFS\s0\fR
should give you access to the complete manual.
.PP
For updates, documentation, and software distribution, please
see the \fB\s-1SFS\s0\fR website at \fIhttp://www.fs.net/\fR.
.SH "BUGS"
.IX Header "BUGS"
\&\fBnfsmounter\fR gets very confused if you unmount file systems
out from under it.
.PP
On some versions of Linux, if you attempt to create an \s-1NFS\s0 loopback
mount but are not running \fBportmap\fR, it appears to wedge the
mountpoint in way that requires a reboot to recover.  The reason is
that the Linux kernel's \s-1NFS\s0 client checks to see if the server is
running various auxiliary daemons used for locking, and gets into a
bad state if it cannot map the port.  There should be a way to recover
from this situation, but the author of \fBnfsmounter\fR does not
know how.  Running \fBportmap\fR after the fact does not help.
Perhaps \fBnfsmounter\fR should have its own built-in portmap to
use in the event that port 111 is not yet bound by any process.
.SH "AUTHOR"
.IX Header "AUTHOR"
sfsdev@redlab.lcs.mit.edu
